binary(move_up,X,Y) :- &pyMoveUp[X](Y), state(X).
binary(move_down,X,Y) :- &pyMoveDown[X](Y), state(X).
binary(move_right,X,Y) :- &pyMoveRight[X](Y), state(X).
binary(move_left,X,Y) :- &pyMoveLeft[X](Y), state(X).

%binary(grab,X,Y) :- &pyGrab[X](Y), state(X).
%binary(drop,X,Y) :- &pyDrop[X](Y), state(X).

%unary(at_top,X) :- &pyAtTop[X](), state(X).
%unary(at_bottom,X) :- &pyAtBottom[X](), state(X).
%unary(at_right,X) :- &pyAtRight[X](), state(X).
%unary(at_left,X) :- &pyAtLeft[X](), state(X).

order(X,Y) :- skolem(X), binary(Y,_,_).
order(X,Y) :- pos_ex(X,_,_), binary(Y,_,_).
order(X,Y) :- pos_ex(X,_,_), skolem(Y).
order(X,Y) :- skolem(X), skolem(Y), X < Y.

{meta(ident,P1,P2,P2)} :- order(P1,P2), deduced(P2,X,Y).
{meta(precon,P1,P2,P3)} :- order(P1,P3), unary(P2,X), deduced(P3,X,Y).
{meta(postcon,P1,P2,P3)} :- order(P1,P2), deduced(P2,X,Y), unary(P3,Y).
{meta(chain,P1,P2,P3)} :- order(P1,P2), order(P1,P3), deduced(P2,X,Z),deduced(P3,Z,Y).
%{meta(tailrec,P1,P2,n)} :- order(P1,P2), deduced(P2,X,Z), deduced(P1,Z,Y).

deduced(P1,X,Y) :- meta(ident,P1,P2,P2), deduced(P2,X,Y).
deduced(P1,X,Y) :- meta(precon,P1,P2,P3), unary(P2,X), deduced(P3,X,Y).
deduced(P1,X,Y) :- meta(postcon,P1,P2,P3), deduced(P2,X,Y), unary(P3,Y).
deduced(P1,X,Y) :- meta(chain,P1,P2,P3), deduced(P2,X,Z), deduced(P3,Z,Y).
%deduced(P1,X,Y) :- meta(tailrec,P1,P2,n), deduced(P2,X,Z), deduced(P1,Z,Y).

state(X) :- pos_ex(_,X,_).
state(Y) :- deduced(_,_,Y).

deduced(P,X,Y) :- binary(P,X,Y).
:- pos_ex(P,X,Y), not deduced(P,X,Y).
%:- pos_ex(P,X,Y1), deduced(P,X,Y2), Y1 != Y2.
:- #count{ M,P1,P2,P3 : meta(M,P1,P2,P3) } != N, size(N).


pos_ex(f,(0,0,1,0,0),(1,0,1,0,0)).
%skolem(0).
%skolem(1).
%size(1).
