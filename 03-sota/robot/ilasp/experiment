#!/usr/bin/env python

import datetime
import os
import shutil
import sys
import contextlib
import time
import threading
import subprocess
import json

try:
    import thread
except ImportError:
    import _thread as thread

from multiprocessing import Pool
from glob import glob
from itertools import product
from collections import defaultdict
from statistics import mean, stdev

POOL_SIZE = 3
#POOL_SIZE = 1

TIMEOUT = 120

TRIALS = 2

MIN_SIZE = 1
MAX_SIZE = 10

goldilocks = None
sys.path.append("../../../systems/goldilocks/")
:q
import chimera.main as goldilocks
from chimera.util import working_directory

def main(args):
    trial, size = args
    task_name = f"size_{size}-trial_{trial}"
    with working_directory("./" + task_name), \
         open("result.txt", "w") as results:
        positions = '\n'.join(map(lambda n: f"x_pos({n}).", range(size+1)))
        shutil.copyfile("../../robots.las", "problem.pl")
        with open("problem.pl", 'a') as problem:
            problem.write(positions + f"""
y_pos(0).
#maxv({size+2}).
"""
)

            problem.write(f"""\
#pos(p1, {{f(w(0,0),w({size},0))}}, {{}}).
#neg(n1, {{f(w(1,0),w(1,0))}}, {{}}).
"""
)
            problem.flush()

            before = time.time()

    #        timer = threading.Timer(TIMEOUT, lambda: print('a') or thread.interrupt_main())
    #        timer.start()
            try:
                cp = subprocess.run(['ilasp', '--clingo5', '--version=2', 'problem.pl'],
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                    timeout=TIMEOUT)
                print(cp.stdout)
                print(cp.stderr)
                print(cp.returncode)
                program = cp.stdout.decode('utf-8')
            except subprocess.TimeoutExpired:
                program = False  # NB: signifies synthesizer did not return
    #        finally:
    #            timer.cancel()

            after = time.time()

            result = {'size': size,
                      'trial': trial,
                      'time': after - before,
                      'program': program}

            print(json.dumps(result, indent=2), file=results)
            print(json.dumps(result, indent=2))

            return result

if __name__ == "__main__":
    DATETIME = str(datetime.datetime.now())
    with working_directory("./" + DATETIME):
        with Pool(POOL_SIZE) as pool:
            trials = range(1, TRIALS+1)
            sizes = range(MIN_SIZE, MAX_SIZE + 1)
            process_args = product(trials, sizes)
            #process_args = [(1,1)]
            results = pool.map(main, process_args)
            collected_results = defaultdict(list)
            for res in results:
                collected_results[res['size']] += [res['time']]

            with open("results.txt", 'w') as results:
                mean_times = defaultdict(dict)
                for i in sizes:
                    times = collected_results[i]
                    mean_times[i] = {'mean': mean(times), 'stdev': stdev(times)}
                results.write(json.dumps(mean_times, indent=2))

